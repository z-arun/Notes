mod_timer(timer, expires) is equivalent to:
del_timer(timer);
timer->expires = expires;
add_timer(timer);
--------------------------------------------------------------.......

root@beaglebone:/boot# ls
config-4.19.94-ti-r42      SOC.sh                     uEnv.txt
dtbs                       System.map-4.19.94-ti-r42  vmlinuz-4.19.94-ti-r42
initrd.img-4.19.94-ti-r42  uboot


----------------------------------------------------------------------------------

The kernel ring buffer is line buffered, which means it's not flushed until it encounters a newline. Add a \n to the end of your printk strings:

All printk() messages are printed to the kernel log buffer, which is a ring buffer exported to userspace through /dev/kmsg. The usual way to read it is using dmesg.

------------------------------------------------------------------------------
Interrupt controller:
The IC hw is connected to all the peripherals (multiplexes the interrupt lines), it collected all the interrupts from all these peripherals and send appropriate sognal to the cpu core
also it groups different interrupt linues together and based on priority it signals the cpu core.
IC can also disale some interrupt lines temporarly.

IRQ - interrupt request.

top halves  -> for fast operation
bottom halves -> for more processing of data.

-------------------------------------------------------------------------------

request_irq(unsigned int irq, irq_handler_t handler, unsigned long flags,
	    const char *name, void *dev)
{
	return request_threaded_irq(irq, handler, NULL, flags, name, dev);
}


/**
 * request_irq - Add a handler for an interrupt line
 * @irq:	The interrupt line to allocate
 * @handler:	Function to be called when the IRQ occurs.
 *		Primary handler for threaded interrupts
 *		If NULL, the default primary handler is installed
 * @flags:	Handling flags
 * @name:	Name of the device generating this interrupt
 * @dev:	A cookie passed to the handler function
 *
 * This call allocates an interrupt and establishes a handler; see
 * the documentation for request_threaded_irq() for details.


--------------------------------------------------------------------------------
/**
 *	free_irq - free an interrupt allocated with request_irq
 *	@irq: Interrupt line to free
 *	@dev_id: Device identity to free
 *
 *	Remove an interrupt handler. The handler is removed and if the
 *	interrupt line is no longer in use by any driver it is disabled.
 *	On a shared IRQ the caller must ensure the interrupt is disabled
 *	on the card it drives before calling this function. The function
 *	does not return until any executing interrupts for this IRQ
 *	have completed.
 *
 *	This function must not be called from interrupt context.
 *
 *	Returns the devname argument passed to request_irq.
 */
const void *free_irq(unsigned int irq, void *dev_id)

--------------------------------------------------------------------------------
handler ::

irq_return fun(int intChannel,void * dev) -> dev to identify th device if line is shared.

--------------------------------------------------------------------------------
interrupt context <-----interrupt handler
process context <------ bottom halves
---
app context.

--------------------------------------------------------------------------------
local_irq_disable();
/* interrupts are disabled .. */
local_irq_enable();

irq_disable();
/* interrupts are disabled .. */
irq_enable();

in_irq() <- top halves -  interrupt handler
in_interrupt <- in process context.

-------------------------------------------------------------------------------------
terrupt handlers run with the current interrupt line disabled on all processors.if  with IRQF_DISABLED run with all other interrupt lines also disabled on the local processor

-------------------------------------------------------------------------------------
bottom halves:::
tasklet (run in interrupt context.) - Two different tasklets can run concurrently on different processors, but two of the same type of tasklet cannot run simultaneously

softirq - fast ,but at compile time . In interrupt context.

workqueue - in process context 

sleep allowed only in workqueue..

---------------------------------------------------------------------------------------
compare tasklet, workqueue,softirq
---------------------------------------------------------------------------------------
kmalloc()
GFP_ATOMIC
Used to allocate memory from interrupt handlers and other code outside of a process context. Never sleeps.

GFP_KERNEL
Normal allocation of kernel memory. May sleep.

GFP_USER
Used to allocate memory for user-space pages; it may sleep.

-----------------------------------------------------------------------------------------------------
The Linux kernel knows about a minimum of three memory zones: DMA-capable memory, normal memory, and high memory

The kmalloc() function guarantees that the pages are physically contiguous (and virtually contiguous).

The vmalloc() function works in a similar fashion to kmalloc(), except it allocates memory that is only virtually contiguous and not necessarily physically contiguous.

{mutex, completion, waitqueuey, signal}
